{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"license/","text":"License \u00b6 Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [2017-2022] [Cisco Systems Inc] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"license/#license","text":"Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION 1. Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. 2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. 3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. 4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. 5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. 6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. 7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. 8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. 9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [2017-2022] [Cisco Systems Inc] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"stacker/","text":"","title":"Stacker"},{"location":"concepts/oci_image_layout/","text":"OCI Image Layout \u00b6","title":"OCI Image Layout"},{"location":"concepts/oci_image_layout/#oci-image-layout","text":"","title":"OCI Image Layout"},{"location":"concepts/stacker_architecture/","text":"Stacker Architecture \u00b6","title":"Stacker Architecture"},{"location":"concepts/stacker_architecture/#stacker-architecture","text":"","title":"Stacker Architecture"},{"location":"developer_guide/CONTRIBUTING/","text":"Getting Started \u00b6 Fork Repository \u00b6 Fork the stacker repository on GitHub to your personal account. #Set golang environment export GOPATH=$HOME/go mkdir -p $GOPATH/src/github.com/project-stacker #Get code go get github.com/project-stacker/stacker cd $GOPATH/src/github.com/project-stacker/stacker #Track repository under your personal account git config push.default nothing # Anything to avoid pushing to project-stacker/stacker by default git remote rename origin project-stacker git remote add $USER git@github.com:$USER/stacker.git git fetch $USER NOTES: Note that GOPATH can be any directory, the example above uses $HOME/go. Change $USER above to your own GitHub username. Build \u00b6 See build instructions in the stacker Developer Guide. Using host's toolchain \u00b6 make Project Structure \u00b6 . ... \u251c\u2500\u2500 atomfs # Source code contains the main atomfs logic \u251c\u2500\u2500 cmd # Source code that handles commandline logic \u251c\u2500\u2500 container # Source code for container management \u251c\u2500\u2500 embed-exec # Source code for converting a file to a exec cmd \u251c\u2500\u2500 lib # Source code contains helper routines \u251c\u2500\u2500 log # Source code that handles logging \u251c\u2500\u2500 mount # Source code that handles the mount logic \u251c\u2500\u2500 mtree # Source code that handles the mtree logic \u251c\u2500\u2500 oci # Source code that handles the OCI layout logic \u251c\u2500\u2500 overlay # Source code that handles overlayfs logic \u251c\u2500\u2500 squashfs # Source code that handles squashfs logic \u251c\u2500\u2500 storage # Source code contains common storage code \u251c\u2500\u2500 test # Source code various unit tests \u251c\u2500\u2500 types # Source code that handles various object types Contribute Workflow \u00b6 PRs are always welcome, even if they only contain small fixes like typos or a few lines of code. If there will be a significant effort, please document it as an issue and get a discussion going before starting to work on it. Please submit a PR broken down into small changes bit by bit. A PR consisting of a lot features and code changes may be hard to review. It is recommended to submit PRs in an incremental fashion. Note: If you split your pull request to small changes, please make sure any of the changes goes to master will not break anything. Otherwise, it can not be merged until this feature complete. Develop, Build and Test \u00b6 Write code on the new branch in your fork. The coding style used in stacker is suggested by the Golang community. See the style doc for details. Try to limit column width to 120 characters for both code and markdown documents such as this one. As we are enforcing standards set by golangci-lint , please always run a full 'make' on source code before committing your changes. This will trigger compilation, unit tests and linting. If it reports an issue, in general, the preferred action is to fix the code. We try to enforce the guideline that code coverage doesn't drop as code is added or modified. Automated Testing (via CI/CD) \u00b6 Once your pull request has been opened, stacker will start a full CI pipeline against it that compiles, and runs unit tests and linters. Reporting issues \u00b6 It is a great way to contribute to stacker by reporting an issue. Well-written and complete bug reports are always welcome! Please open an issue on Github and follow the template to fill in required information. Before opening any issue, please look up the existing issues to avoid submitting a duplication. If you find a match, you can \"subscribe\" to it to get notified on updates. If you have additional helpful information about the issue, please leave a comment. When reporting issues, always include: Build environment (golang compiler, etc) Configuration files of stacker Log files as per configuration. Because the issues are open to the public, when submitting the log and configuration files, be sure to remove any sensitive information, e.g. user name, password, IP address, and company name. You can replace those parts with \"REDACTED\" or other strings like \"****\". Be sure to include the steps to reproduce the problem if applicable. It can help us understand and fix your issue faster. Documenting \u00b6 Update the documentation if you are creating or changing features. Good documentation is as important as the code itself. The main location for the documentation is the website repository. The images referred to in documents can be placed in docs/img in that repo. Documents are written with Markdown. See Writing on GitHub for more details. Design New Features \u00b6 You can propose new designs for existing stacker features. You can also design entirely new features, Please submit a proposal in GitHub issues. stacker maintainers will review this proposal as soon as possible. This is necessary to ensure the overall architecture is consistent and to avoid duplicated work in the roadmap.","title":"Contributing"},{"location":"developer_guide/CONTRIBUTING/#getting-started","text":"","title":"Getting Started"},{"location":"developer_guide/CONTRIBUTING/#fork-repository","text":"Fork the stacker repository on GitHub to your personal account. #Set golang environment export GOPATH=$HOME/go mkdir -p $GOPATH/src/github.com/project-stacker #Get code go get github.com/project-stacker/stacker cd $GOPATH/src/github.com/project-stacker/stacker #Track repository under your personal account git config push.default nothing # Anything to avoid pushing to project-stacker/stacker by default git remote rename origin project-stacker git remote add $USER git@github.com:$USER/stacker.git git fetch $USER NOTES: Note that GOPATH can be any directory, the example above uses $HOME/go. Change $USER above to your own GitHub username.","title":"Fork Repository"},{"location":"developer_guide/CONTRIBUTING/#build","text":"See build instructions in the stacker Developer Guide.","title":"Build"},{"location":"developer_guide/CONTRIBUTING/#using-hosts-toolchain","text":"make","title":"Using host's toolchain"},{"location":"developer_guide/CONTRIBUTING/#project-structure","text":". ... \u251c\u2500\u2500 atomfs # Source code contains the main atomfs logic \u251c\u2500\u2500 cmd # Source code that handles commandline logic \u251c\u2500\u2500 container # Source code for container management \u251c\u2500\u2500 embed-exec # Source code for converting a file to a exec cmd \u251c\u2500\u2500 lib # Source code contains helper routines \u251c\u2500\u2500 log # Source code that handles logging \u251c\u2500\u2500 mount # Source code that handles the mount logic \u251c\u2500\u2500 mtree # Source code that handles the mtree logic \u251c\u2500\u2500 oci # Source code that handles the OCI layout logic \u251c\u2500\u2500 overlay # Source code that handles overlayfs logic \u251c\u2500\u2500 squashfs # Source code that handles squashfs logic \u251c\u2500\u2500 storage # Source code contains common storage code \u251c\u2500\u2500 test # Source code various unit tests \u251c\u2500\u2500 types # Source code that handles various object types","title":"Project Structure"},{"location":"developer_guide/CONTRIBUTING/#contribute-workflow","text":"PRs are always welcome, even if they only contain small fixes like typos or a few lines of code. If there will be a significant effort, please document it as an issue and get a discussion going before starting to work on it. Please submit a PR broken down into small changes bit by bit. A PR consisting of a lot features and code changes may be hard to review. It is recommended to submit PRs in an incremental fashion. Note: If you split your pull request to small changes, please make sure any of the changes goes to master will not break anything. Otherwise, it can not be merged until this feature complete.","title":"Contribute Workflow"},{"location":"developer_guide/CONTRIBUTING/#develop-build-and-test","text":"Write code on the new branch in your fork. The coding style used in stacker is suggested by the Golang community. See the style doc for details. Try to limit column width to 120 characters for both code and markdown documents such as this one. As we are enforcing standards set by golangci-lint , please always run a full 'make' on source code before committing your changes. This will trigger compilation, unit tests and linting. If it reports an issue, in general, the preferred action is to fix the code. We try to enforce the guideline that code coverage doesn't drop as code is added or modified.","title":"Develop, Build and Test"},{"location":"developer_guide/CONTRIBUTING/#automated-testing-via-cicd","text":"Once your pull request has been opened, stacker will start a full CI pipeline against it that compiles, and runs unit tests and linters.","title":"Automated Testing (via CI/CD)"},{"location":"developer_guide/CONTRIBUTING/#reporting-issues","text":"It is a great way to contribute to stacker by reporting an issue. Well-written and complete bug reports are always welcome! Please open an issue on Github and follow the template to fill in required information. Before opening any issue, please look up the existing issues to avoid submitting a duplication. If you find a match, you can \"subscribe\" to it to get notified on updates. If you have additional helpful information about the issue, please leave a comment. When reporting issues, always include: Build environment (golang compiler, etc) Configuration files of stacker Log files as per configuration. Because the issues are open to the public, when submitting the log and configuration files, be sure to remove any sensitive information, e.g. user name, password, IP address, and company name. You can replace those parts with \"REDACTED\" or other strings like \"****\". Be sure to include the steps to reproduce the problem if applicable. It can help us understand and fix your issue faster.","title":"Reporting issues"},{"location":"developer_guide/CONTRIBUTING/#documenting","text":"Update the documentation if you are creating or changing features. Good documentation is as important as the code itself. The main location for the documentation is the website repository. The images referred to in documents can be placed in docs/img in that repo. Documents are written with Markdown. See Writing on GitHub for more details.","title":"Documenting"},{"location":"developer_guide/CONTRIBUTING/#design-new-features","text":"You can propose new designs for existing stacker features. You can also design entirely new features, Please submit a proposal in GitHub issues. stacker maintainers will review this proposal as soon as possible. This is necessary to ensure the overall architecture is consistent and to avoid duplicated work in the roadmap.","title":"Design New Features"},{"location":"developer_guide/building_stacker/","text":"Building and Installing Stacker \u00b6 Go Dependency \u00b6 Stacker requires at least go 1.11. Ubuntu 20.04 \u00b6 On Ubuntu 20.04 you can install Go using the instructions at: https://github.com/golang/go/wiki/Ubuntu Fedora 31 \u00b6 On Fedora 31 you can install Go with the following command: sudo dnf install golang Other Distributions \u00b6 If Go is not already packaged for your Linux distribution, you can get the latest Go version here: https://golang.org/dl/#stable Go can be installed using the instructions on on the official Go website: https://golang.org/doc/install#install Other Dependencies \u00b6 Ubuntu 20.04 \u00b6 The other build dependencies can be satisfied with the following command and packages: sudo apt install lxc-dev libacl1-dev libgpgme-dev libcap-dev libseccomp-dev sudo apt install libpam0g-dev libselinux-dev libssl-dev libzstd-dev libcryptsetup-dev libdevmapper-dev Ubuntu 22.04 \u00b6 sudo apt install lxc-dev libacl1-dev libgpgme-dev libcap-dev libseccomp-dev sudo apt install libpam0g-dev libselinux-dev libssl-dev libzstd-dev libcryptsetup-dev libdevmapper-dev cryptsetup-bin pkg-config libsquashfs1 libsquashfs-dev To run make check you will also need: sudo apt install bats jq tree umoci - https://github.com/opencontainers/umoci squashtool , but with a slightly different config than what is mentioned in the install guide (see below) - https://github.com/anuvu/squashfs Contrary to what the documentation in squashfs implies, squashtool and libsquash from squash-tools-ng need to be installed globally, as user specific path overrides aren't propagated into make check 's test envs. Thus, when you reach the step install into mylocal=\"$HOME/lib\" from the squashfs guide, use the config below. You can put them at the end of your .bashrc file so you don't need to run them every time. mylocal=\"/usr/local\" export LD_LIBRARY_PATH=$mylocal/lib${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}} export PKG_CONFIG_PATH=$mylocal/lib/pkgconfig${PKG_CONFIG_PATH:+:$PKG_CONFIG_PATH} Since the path /usr/local is owned by root, when you reach the step to run make install , you need to run it as sudo . make check requires the golangci-lint binary to be present in $GOPATH/bin Since there are some tests that run with elevated privileges and use git, it will complain that the stacker folder is unsafe as it is owned by your user. To prevent that, we need to tell git to consider that folder as safe. To do this, open your git config file ( .gitconfig ) and add the following line with the path to your local stacker folder. Below is an example: [safe] directory = /home/chofnar/github/stacker Fedora 31 \u00b6 The other build dependencies can be satisfied with the following command and packages: sudo dnf install lxc-devel libcap-devel libacl-devel gpgme-devel sudo dnf install bats jq Building the Stacker Binary \u00b6 Finally, once you have the build dependencies, stacker can be built with a simple make . The stacker binary will be output as ./stacker .","title":"Building Stacker"},{"location":"developer_guide/building_stacker/#building-and-installing-stacker","text":"","title":"Building and Installing Stacker"},{"location":"developer_guide/building_stacker/#go-dependency","text":"Stacker requires at least go 1.11.","title":"Go Dependency"},{"location":"developer_guide/building_stacker/#ubuntu-2004","text":"On Ubuntu 20.04 you can install Go using the instructions at: https://github.com/golang/go/wiki/Ubuntu","title":"Ubuntu 20.04"},{"location":"developer_guide/building_stacker/#fedora-31","text":"On Fedora 31 you can install Go with the following command: sudo dnf install golang","title":"Fedora 31"},{"location":"developer_guide/building_stacker/#other-distributions","text":"If Go is not already packaged for your Linux distribution, you can get the latest Go version here: https://golang.org/dl/#stable Go can be installed using the instructions on on the official Go website: https://golang.org/doc/install#install","title":"Other Distributions"},{"location":"developer_guide/building_stacker/#other-dependencies","text":"","title":"Other Dependencies"},{"location":"developer_guide/building_stacker/#ubuntu-2004_1","text":"The other build dependencies can be satisfied with the following command and packages: sudo apt install lxc-dev libacl1-dev libgpgme-dev libcap-dev libseccomp-dev sudo apt install libpam0g-dev libselinux-dev libssl-dev libzstd-dev libcryptsetup-dev libdevmapper-dev","title":"Ubuntu 20.04"},{"location":"developer_guide/building_stacker/#ubuntu-2204","text":"sudo apt install lxc-dev libacl1-dev libgpgme-dev libcap-dev libseccomp-dev sudo apt install libpam0g-dev libselinux-dev libssl-dev libzstd-dev libcryptsetup-dev libdevmapper-dev cryptsetup-bin pkg-config libsquashfs1 libsquashfs-dev To run make check you will also need: sudo apt install bats jq tree umoci - https://github.com/opencontainers/umoci squashtool , but with a slightly different config than what is mentioned in the install guide (see below) - https://github.com/anuvu/squashfs Contrary to what the documentation in squashfs implies, squashtool and libsquash from squash-tools-ng need to be installed globally, as user specific path overrides aren't propagated into make check 's test envs. Thus, when you reach the step install into mylocal=\"$HOME/lib\" from the squashfs guide, use the config below. You can put them at the end of your .bashrc file so you don't need to run them every time. mylocal=\"/usr/local\" export LD_LIBRARY_PATH=$mylocal/lib${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}} export PKG_CONFIG_PATH=$mylocal/lib/pkgconfig${PKG_CONFIG_PATH:+:$PKG_CONFIG_PATH} Since the path /usr/local is owned by root, when you reach the step to run make install , you need to run it as sudo . make check requires the golangci-lint binary to be present in $GOPATH/bin Since there are some tests that run with elevated privileges and use git, it will complain that the stacker folder is unsafe as it is owned by your user. To prevent that, we need to tell git to consider that folder as safe. To do this, open your git config file ( .gitconfig ) and add the following line with the path to your local stacker folder. Below is an example: [safe] directory = /home/chofnar/github/stacker","title":"Ubuntu 22.04"},{"location":"developer_guide/building_stacker/#fedora-31_1","text":"The other build dependencies can be satisfied with the following command and packages: sudo dnf install lxc-devel libcap-devel libacl-devel gpgme-devel sudo dnf install bats jq","title":"Fedora 31"},{"location":"developer_guide/building_stacker/#building-the-stacker-binary","text":"Finally, once you have the build dependencies, stacker can be built with a simple make . The stacker binary will be output as ./stacker .","title":"Building the Stacker Binary"},{"location":"developer_guide/code_structure/","text":"Project Structure \u00b6 . ... \u251c\u2500\u2500 atomfs # Source code contains the main atomfs logic \u251c\u2500\u2500 cmd # Source code that handles commandline logic \u251c\u2500\u2500 container # Source code for container management \u251c\u2500\u2500 embed-exec # Source code for converting a file to a exec cmd \u251c\u2500\u2500 lib # Source code contains helper routines \u251c\u2500\u2500 log # Source code that handles logging \u251c\u2500\u2500 mount # Source code that handles the mount logic \u251c\u2500\u2500 mtree # Source code that handles the mtree logic \u251c\u2500\u2500 oci # Source code that handles the OCI layout logic \u251c\u2500\u2500 overlay # Source code that handles overlayfs logic \u251c\u2500\u2500 squashfs # Source code that handles squashfs logic \u251c\u2500\u2500 storage # Source code contains common storage code \u251c\u2500\u2500 test # Source code various unit tests \u251c\u2500\u2500 types # Source code that handles various object types","title":"Code Structure"},{"location":"developer_guide/code_structure/#project-structure","text":". ... \u251c\u2500\u2500 atomfs # Source code contains the main atomfs logic \u251c\u2500\u2500 cmd # Source code that handles commandline logic \u251c\u2500\u2500 container # Source code for container management \u251c\u2500\u2500 embed-exec # Source code for converting a file to a exec cmd \u251c\u2500\u2500 lib # Source code contains helper routines \u251c\u2500\u2500 log # Source code that handles logging \u251c\u2500\u2500 mount # Source code that handles the mount logic \u251c\u2500\u2500 mtree # Source code that handles the mtree logic \u251c\u2500\u2500 oci # Source code that handles the OCI layout logic \u251c\u2500\u2500 overlay # Source code that handles overlayfs logic \u251c\u2500\u2500 squashfs # Source code that handles squashfs logic \u251c\u2500\u2500 storage # Source code contains common storage code \u251c\u2500\u2500 test # Source code various unit tests \u251c\u2500\u2500 types # Source code that handles various object types","title":"Project Structure"},{"location":"developer_guide/lxc_usage/","text":"","title":"LXC Usage"},{"location":"developer_guide/overlayfs_usage/","text":"","title":"OverlayFS Usage"},{"location":"get_started/get_stacker/","text":"Stacker is a single static binary tool with most of the dependencies built into the binary. Stacker, however, depends on specific kernel capabilities and system tools to provide various features. Download Stacker wget https://github.com/project-stacker/stacker/releases/latest/download/stacker chmod +x ./stacker sudo cp ./stacker /usr/bin/stacker stacker --version stacker check Kernel dependencies \u00b6 Stacker requires overlayfs backend, and that works with any kernel >= 4.14. However, for unprivileged use, the overlayfs backend requires a reasonably new kernel change available on all kernels >= 5.8. Info Overlayfs kernel patches required for unprivileged use: vfs: allow unprivileged whiteout creation - a3c751a50fe6 ovl: unprivieged mounts - 459c7c565ac3 Some distributions may have ported these patches into older versions of their kernels. For example, Ubuntu 20.04 and 22.04 kernels already have these patches. Stacker has checks to ensure that it can run with all these environments requirements, and will fail fast if it can't do something it should be able to do. Stacker Check stacker check && echo \"stacker is ready to use!\" Overlay filesystem \u00b6 An underlying overlayfs cannot back stacker since the stacker needs to create whiteout files, and the kernel (rightfully) forbids manual creation of whiteout files on overlay filesystems. No additional userspace dependencies are required to use the overlayfs backend. Warning Do not use a overlayfs based filesystem as a storage for stacker root directory. Unprivileged setup \u00b6 Running stacker as an unprivileged user requires stacker to run inside a user namespace owned by the user that executed the command, and stacker will try to map 65k user and group ids to meet the POSIX standard. So, to run stacker, the user's /etc/sub{u,g}id should be configured with enough uids to map things correctly. This configuration can be done automatically via stacker unpriv-setup . Stacker unprivileged setup sudo stacker unpriv-setup cat /etc/subgid cat /etc/subuid Squashfs support \u00b6 In order to generate squashfs images, stacker invokes the mksquashfs binary. This binary needs to be installed and present in $PATH . Install mksquashfs on ubuntu sudo apt-get install -y squashfs-tools","title":"Get Stacker"},{"location":"get_started/get_stacker/#kernel-dependencies","text":"Stacker requires overlayfs backend, and that works with any kernel >= 4.14. However, for unprivileged use, the overlayfs backend requires a reasonably new kernel change available on all kernels >= 5.8. Info Overlayfs kernel patches required for unprivileged use: vfs: allow unprivileged whiteout creation - a3c751a50fe6 ovl: unprivieged mounts - 459c7c565ac3 Some distributions may have ported these patches into older versions of their kernels. For example, Ubuntu 20.04 and 22.04 kernels already have these patches. Stacker has checks to ensure that it can run with all these environments requirements, and will fail fast if it can't do something it should be able to do. Stacker Check stacker check && echo \"stacker is ready to use!\"","title":"Kernel dependencies"},{"location":"get_started/get_stacker/#overlay-filesystem","text":"An underlying overlayfs cannot back stacker since the stacker needs to create whiteout files, and the kernel (rightfully) forbids manual creation of whiteout files on overlay filesystems. No additional userspace dependencies are required to use the overlayfs backend. Warning Do not use a overlayfs based filesystem as a storage for stacker root directory.","title":"Overlay filesystem"},{"location":"get_started/get_stacker/#unprivileged-setup","text":"Running stacker as an unprivileged user requires stacker to run inside a user namespace owned by the user that executed the command, and stacker will try to map 65k user and group ids to meet the POSIX standard. So, to run stacker, the user's /etc/sub{u,g}id should be configured with enough uids to map things correctly. This configuration can be done automatically via stacker unpriv-setup . Stacker unprivileged setup sudo stacker unpriv-setup cat /etc/subgid cat /etc/subuid","title":"Unprivileged setup"},{"location":"get_started/get_stacker/#squashfs-support","text":"In order to generate squashfs images, stacker invokes the mksquashfs binary. This binary needs to be installed and present in $PATH . Install mksquashfs on ubuntu sudo apt-get install -y squashfs-tools","title":"Squashfs support"},{"location":"get_started/hello_stacker_image/","text":"Stacker builds OCI images using the YAML definition in a file referred to as the stacker file. So let's create a stacker file definition that packages a simple \"Hello Stacker!\" script into an OCI container image. Hello Stacker hello-stacker : from : type : docker url : docker://zothub.io/tools/busybox:stable run : | mkdir -p /hello-stacker-app echo 'echo \"Hello Stacker!\"' > /hello-stacker-app/hello.sh chmod +x /hello-stacker-app/hello.sh entrypoint : /hello-stacker-app/hello.sh hello-stacker , the first key in the above YAML, builds an OCI image named hello-stacker . The from section defines that hello-stacker image builds on top of an existing image called zothub.io/tools/busybox:stable , and that the base image is of type docker downloaded from URL docker://zothub.io/tools/busybox:stable . The run section defines a build script. This script is executed on top of the ubuntu image's root file system, creates a file called /hello-stacker-app/hello.sh , and makes it executable. entrypoint defines that /hello-stacker-app/hello.sh is executed as the init process on creating this container by a container runtime. We can create the hello-stacker image with this input as a stacker file name hello_stacker.yaml . Hello Stacker Build $ stacker build -f hello_stacker.yaml preparing image hello-stacker... loading docker://zothub.io/tools/busybox:stable Copying blob cf92e523b49e done Copying config cb52c703ef done Writing manifest to image destination Storing signatures + mkdir -p /hello-stacker-app + echo echo \"Hello Stacker!\" + chmod +x /hello-stacker-app/hello.sh filesystem hello-stacker built successfully stacker build used hello-stacker.yaml as input, downloaded the zothub.io/tools/busybox:stable image from docker hub and generated an OCI image with tag hello-stacker . We can verify this using stacker inspect : Stacker Inspect $ stacker inspect hello-stacker layer 0 : cf92e523b49e... ( 30 MB, application/vnd.oci.image.layer.v1.tar+gzip ) layer 1 : 2910d371807c... ( 176 B, application/vnd.oci.image.layer.v1.tar+gzip ) Annotations: io.stackeroci.stacker.stacker_yaml: hello-stacker: from: type: docker url: docker://zothub.io/tools/busybox:stable run: | mkdir -p /hello-stacker-app echo 'echo \"Hello Stacker!\"' > /hello-stacker-app/hello.sh chmod +x /hello-stacker-app/hello.sh entrypoint: /hello-stacker-app/hello.sh Image config: { \"created\" : \"2022-10-24T03:47:24.374578534Z\" , \"author\" : \"stacker-dev\" , \"architecture\" : \"amd64\" , \"os\" : \"linux\" , \"config\" : { \"Env\" : [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\" ] , \"Entrypoint\" : [ \"/hello-stacker-app/hello.sh\" ] } , \"rootfs\" : { \"type\" : \"layers\" , \"diff_ids\" : [ \"sha256:17f623af01e277c5ffe6779af8164907de02d9af7a0e161662fc735dd64f117b\" , \"sha256:a33ac624796108439088267fb525f1038dccb6f6a50796a1593786a31d97a4bd\" ] } , \"history\" : [ { \"created\" : \"2022-10-04T23:35:20.465021967Z\" , \"created_by\" : \"/bin/sh -c #(nop) ADD file:6cd2e13356aa5339c1f2abd3c210a52f6ed74fae05cd61aa09f37b6a4764f65c in / \" } , { \"created\" : \"2022-10-04T23:35:20.857335994Z\" , \"created_by\" : \"/bin/sh -c #(nop) CMD [\\\"bash\\\"]\" , \"empty_layer\" : true } , { \"created\" : \"2022-10-24T03:47:24.372946511Z\" , \"created_by\" : \"stacker build of hello-stacker\" } , { \"created\" : \"2022-10-24T03:47:24.374578534Z\" , \"created_by\" : \"stacker build\" , \"author\" : \"root@ins15-pp24-ru11\" , \"empty_layer\" : true } ] } The next thing to note is that if we rebuild the image without any modifications to the stacker file, less things happen: stacker caching $ stacker build -f hello_stacker.yaml preparing image hello-stacker... loading docker://zothub.io/tools/busybox:stable Copying blob cf92e523b49e skipped: already exists Copying config cb52c703ef done Writing manifest to image destination Storing signatures found cached layer hello-stacker Stacker will cache all inputs to the stacker file and rebuilds the image only if something changed in the stacker file. The cache and the metadata required to track the build state live in the .stacker directory where the stacker command is run. Stacker cache can be cleaned using stacker clean command.","title":"Hello Stacker Image"},{"location":"reference/stacker_cli/","text":"Stacker CLI \u00b6","title":"Stacker CLI"},{"location":"reference/stacker_cli/#stacker-cli","text":"","title":"Stacker CLI"},{"location":"reference/stacker_file/","text":"The stacker.yaml file \u00b6 When doing a stacker build , the behavior of stacker is specified by the yaml directives below. In addition to these, stacker allows variable substitions of several forms. For example, a line like: $ONE ${{TWO}} ${{THREE:3}} When run with stacker build --substitute ONE=1 --substitute TWO=2 is processed in stacker as: 1 2 3 That is, variables of the form $FOO or ${FOO} are supported, and variables with ${FOO:default} a default value will evaluate to their default if not specified on the command line. It is an error to specify a ${FOO} style without a default; to make the default an empty string, use ${FOO:} . In addition to substitutions provided on the command line, the following variables are also available with their values from either command line flags or stacker-config file. STACKER_STACKER_DIR config name 'stacker_dir', cli flag '--stacker-dir'- STACKER_ROOTFS_DIR config name 'rootfs_dir', cli flag '--roots-dir' STACKER_OCI_DIR config name 'oci_dir', cli flag '--oci-dir' The stacker build environment will have the following environment variables available for reference: STACKER_LAYER_NAME : the name of the layer being built. STACKER_LAYER_NAME will be my-build when the run section below is executed. my-build : run : echo \"Your layer is ${STACKER_LAYER_NAME}\" from \u00b6 The from directive describes the base image that stacker will start from. It takes the form: from: type: $type url: $url tag: $tag insecure: true Some directives are irrelevant depending on the type. Supported types are: docker : url is required, insecure is optional. When insecure is specified, stacker attempts to connect via http instead of https to the Docker Hub. tar : url is required, everything else is ignored. oci : url is required, of the form path:tag . This uses the OCI image at url (which may be a local path). built : tag is required, everything else is ignored. built bases this layer on a previously specified layer in the stacker file. import \u00b6 The import directive describes what files should be made available in /stacker during the run phase. There are three forms of importing supported today: /path/to/file Will import a file or directory from the local filesystem. If the file or directory changes between stacker builds, it will be hashed and the new file will be imported on subsequent builds. http://example.com/foo.tar.gz Will import foo.tar.gz and make it available in /stacker . Note that stacker will NOT update this file unless the cache is cleared, to avoid excess network usage. That means that updates after the first time stacker downloads the file will not be reflected. stacker://$name/path/to/file Will grab /path/to/file from the previously built layer $name . import hash \u00b6 The import directive also supports specifying the hash(sha256sum) of import source, for all the three forms presented above, for example: import: - path: config.json hash: f55af805b012017bc.... - path: http://example.com/foo.tar.gz hash: b458dfd63e7883a64.... - path: stacker://$name/path/to/file hash: f805b012017bc769a.... Before copying the file it will check if the requested hash matches the actual one. stacker build supports the flag --require-flag which checks that all http(s) remote imports have an hash in all stacker YAMLs. This new import mode can be combined with the old one, for example: import: - path: \"config.json hash: \"BEEFcafeaaaaAAAA....\" - /path/to/file overlay_dirs \u00b6 This directive works only with OverlayFS backend storage. The overlay_dirs directive describes what directories (content) from the host should be available in the container's filesystem. It preserves all file/dirs attributes but no owner or group. overlay_dirs: - source: /path/to/directory dest: /usr/local/ ## optional arg, default is '/' - source: /path/to/directory2 This example will result in all the files/dirs from the host's /path/to/directory to be available under container's /usr/local/ and all the files/dirs from the host's /path/to/directory2 to be available under container's / environment , labels , working_dir , volumes , cmd , entrypoint , user \u00b6 These all correspond exactly to the similarly named bits in the OCI image config spec , and are available for users to pass things through to the runtime environment of the image. generate_labels \u00b6 The generate_labels entry is similar to run in that it contains a list of commands to run inside the generated rootfs. It runs after the run section is done, and its mutations to the filesystem are not recorded, except in one case /oci-labels . /oci-labels is a special directory where this code can write a file, and the name of the file will be the OCI label name, and the content will be the label content. build_env and build_env_passthrough \u00b6 By default, environment variables do not pass through (pollute) the build environment. build_env : this is a dictionary with environment variable definitions. their values will be present in the build's environment. build_env_passthrough : This is a list of regular expressions that work as a filter on which environment variables should be passed through from the current env into the container. To let all variables through simply set build_env_passthrough : [\".*\"] If build_env_passthrough is not set, then the default value is to allow through proxy variables HTTP_PROXY, HTTPS_PROXY, FTP_PROXY, http_proxy, https_proxy, ftp_proxy . Values in the build_env override values passed through via full_command \u00b6 Because of the odd behavior of cmd and entrypoint (and the inherited nature of these from previous stacker layers), full_command provides a way to set the full command that will be executed in the image, clearing out any previous cmd and entrypoint values that were set in the image. build_only \u00b6 build_only : indicates whether or not to include this layer in the final OCI image. This can be useful in conjunction with an import from this layer in another image, if you want to isolate the build environment for a binary but not include all of its build dependencies. binds \u00b6 binds : specifies bind mounts from the host to the container. There are two formats: binds: - /foo/bar -> /bar/baz - /zomg The first one binds /foo/bar to /bar/baz, and the second host /zomg to container /zomg. Right now there is no awareness of change for any of these bind mounts, so --no-cache should be used to re-build if the content of the bind mount has changed. config \u00b6 config key is a special type of entry in the root in the stacker.yaml file. It cannot contain a layer definition, it is used to provide configuration applicable for building all the layers defined in this file. For example, config: prerequisites: - ../folder2/stacker.yaml - ../folder3/stacker.yaml prerequisites \u00b6 If the prerequisites list is present under the config key, stacker will make sure to build all the layers in the stacker.yaml files found at the paths contained in the list. This way stacker supports building multiple stacker.yaml files in the correct order. In this particular case the parent folder of the current folder, let's call it parent , has 3 subfolders folder1 , folder2 and folder3 , each containing a stacker.yaml file. The example config above is in parent/folder1/stacker.yaml . When stacker build -f parent/folder1/stacker.yaml is invoked, stacker would search for the other two stacker.yaml files and build them first, before building the stacker.yaml specified in the command line. annotations \u00b6 annotations is a user-specified key value map that will be included in the final OCI image. Note that these annotations are included in the image manifest itself and not as part of the index.json. annotations: a.b.c.key: abc_val p.q.r.key: pqr_val While config section supports a similar labels , it is more pertitent to the image runtime. On the other hand, annotations is intended to be image-specific metadata aligned with the annotations in the image spec .","title":"Stacker File"},{"location":"reference/stacker_file/#the-stackeryaml-file","text":"When doing a stacker build , the behavior of stacker is specified by the yaml directives below. In addition to these, stacker allows variable substitions of several forms. For example, a line like: $ONE ${{TWO}} ${{THREE:3}} When run with stacker build --substitute ONE=1 --substitute TWO=2 is processed in stacker as: 1 2 3 That is, variables of the form $FOO or ${FOO} are supported, and variables with ${FOO:default} a default value will evaluate to their default if not specified on the command line. It is an error to specify a ${FOO} style without a default; to make the default an empty string, use ${FOO:} . In addition to substitutions provided on the command line, the following variables are also available with their values from either command line flags or stacker-config file. STACKER_STACKER_DIR config name 'stacker_dir', cli flag '--stacker-dir'- STACKER_ROOTFS_DIR config name 'rootfs_dir', cli flag '--roots-dir' STACKER_OCI_DIR config name 'oci_dir', cli flag '--oci-dir' The stacker build environment will have the following environment variables available for reference: STACKER_LAYER_NAME : the name of the layer being built. STACKER_LAYER_NAME will be my-build when the run section below is executed. my-build : run : echo \"Your layer is ${STACKER_LAYER_NAME}\"","title":"The stacker.yaml file"},{"location":"reference/stacker_file/#from","text":"The from directive describes the base image that stacker will start from. It takes the form: from: type: $type url: $url tag: $tag insecure: true Some directives are irrelevant depending on the type. Supported types are: docker : url is required, insecure is optional. When insecure is specified, stacker attempts to connect via http instead of https to the Docker Hub. tar : url is required, everything else is ignored. oci : url is required, of the form path:tag . This uses the OCI image at url (which may be a local path). built : tag is required, everything else is ignored. built bases this layer on a previously specified layer in the stacker file.","title":"from"},{"location":"reference/stacker_file/#import","text":"The import directive describes what files should be made available in /stacker during the run phase. There are three forms of importing supported today: /path/to/file Will import a file or directory from the local filesystem. If the file or directory changes between stacker builds, it will be hashed and the new file will be imported on subsequent builds. http://example.com/foo.tar.gz Will import foo.tar.gz and make it available in /stacker . Note that stacker will NOT update this file unless the cache is cleared, to avoid excess network usage. That means that updates after the first time stacker downloads the file will not be reflected. stacker://$name/path/to/file Will grab /path/to/file from the previously built layer $name .","title":"import"},{"location":"reference/stacker_file/#import-hash","text":"The import directive also supports specifying the hash(sha256sum) of import source, for all the three forms presented above, for example: import: - path: config.json hash: f55af805b012017bc.... - path: http://example.com/foo.tar.gz hash: b458dfd63e7883a64.... - path: stacker://$name/path/to/file hash: f805b012017bc769a.... Before copying the file it will check if the requested hash matches the actual one. stacker build supports the flag --require-flag which checks that all http(s) remote imports have an hash in all stacker YAMLs. This new import mode can be combined with the old one, for example: import: - path: \"config.json hash: \"BEEFcafeaaaaAAAA....\" - /path/to/file","title":"import hash"},{"location":"reference/stacker_file/#overlay_dirs","text":"This directive works only with OverlayFS backend storage. The overlay_dirs directive describes what directories (content) from the host should be available in the container's filesystem. It preserves all file/dirs attributes but no owner or group. overlay_dirs: - source: /path/to/directory dest: /usr/local/ ## optional arg, default is '/' - source: /path/to/directory2 This example will result in all the files/dirs from the host's /path/to/directory to be available under container's /usr/local/ and all the files/dirs from the host's /path/to/directory2 to be available under container's /","title":"overlay_dirs"},{"location":"reference/stacker_file/#environment-labels-working_dir-volumes-cmd-entrypoint-user","text":"These all correspond exactly to the similarly named bits in the OCI image config spec , and are available for users to pass things through to the runtime environment of the image.","title":"environment, labels, working_dir, volumes, cmd, entrypoint, user"},{"location":"reference/stacker_file/#generate_labels","text":"The generate_labels entry is similar to run in that it contains a list of commands to run inside the generated rootfs. It runs after the run section is done, and its mutations to the filesystem are not recorded, except in one case /oci-labels . /oci-labels is a special directory where this code can write a file, and the name of the file will be the OCI label name, and the content will be the label content.","title":"generate_labels"},{"location":"reference/stacker_file/#build_env-and-build_env_passthrough","text":"By default, environment variables do not pass through (pollute) the build environment. build_env : this is a dictionary with environment variable definitions. their values will be present in the build's environment. build_env_passthrough : This is a list of regular expressions that work as a filter on which environment variables should be passed through from the current env into the container. To let all variables through simply set build_env_passthrough : [\".*\"] If build_env_passthrough is not set, then the default value is to allow through proxy variables HTTP_PROXY, HTTPS_PROXY, FTP_PROXY, http_proxy, https_proxy, ftp_proxy . Values in the build_env override values passed through via","title":"build_env and build_env_passthrough"},{"location":"reference/stacker_file/#full_command","text":"Because of the odd behavior of cmd and entrypoint (and the inherited nature of these from previous stacker layers), full_command provides a way to set the full command that will be executed in the image, clearing out any previous cmd and entrypoint values that were set in the image.","title":"full_command"},{"location":"reference/stacker_file/#build_only","text":"build_only : indicates whether or not to include this layer in the final OCI image. This can be useful in conjunction with an import from this layer in another image, if you want to isolate the build environment for a binary but not include all of its build dependencies.","title":"build_only"},{"location":"reference/stacker_file/#binds","text":"binds : specifies bind mounts from the host to the container. There are two formats: binds: - /foo/bar -> /bar/baz - /zomg The first one binds /foo/bar to /bar/baz, and the second host /zomg to container /zomg. Right now there is no awareness of change for any of these bind mounts, so --no-cache should be used to re-build if the content of the bind mount has changed.","title":"binds"},{"location":"reference/stacker_file/#config","text":"config key is a special type of entry in the root in the stacker.yaml file. It cannot contain a layer definition, it is used to provide configuration applicable for building all the layers defined in this file. For example, config: prerequisites: - ../folder2/stacker.yaml - ../folder3/stacker.yaml","title":"config"},{"location":"reference/stacker_file/#prerequisites","text":"If the prerequisites list is present under the config key, stacker will make sure to build all the layers in the stacker.yaml files found at the paths contained in the list. This way stacker supports building multiple stacker.yaml files in the correct order. In this particular case the parent folder of the current folder, let's call it parent , has 3 subfolders folder1 , folder2 and folder3 , each containing a stacker.yaml file. The example config above is in parent/folder1/stacker.yaml . When stacker build -f parent/folder1/stacker.yaml is invoked, stacker would search for the other two stacker.yaml files and build them first, before building the stacker.yaml specified in the command line.","title":"prerequisites"},{"location":"reference/stacker_file/#annotations","text":"annotations is a user-specified key value map that will be included in the final OCI image. Note that these annotations are included in the image manifest itself and not as part of the index.json. annotations: a.b.c.key: abc_val p.q.r.key: pqr_val While config section supports a similar labels , it is more pertitent to the image runtime. On the other hand, annotations is intended to be image-specific metadata aligned with the annotations in the image spec .","title":"annotations"},{"location":"user_guide/annotation_support/","text":"","title":"Annotation Support"},{"location":"user_guide/build_cache/","text":"","title":"Build Cache"},{"location":"user_guide/build_code/","text":"A common first step before building a container image is to build your code in a consistent environment. Stacker provides a hermetically sealed environment in a build-only container to produce the binaries and other artifacts required for the container image. Whether you are building a container image or not, it is a good idea to use stacker's container-based builds to produce your binaries, especially when you need a consistent build environment for all the developers collaborating on the same project. Go Code Example \u00b6 As an example, let's build a simple go file using stacker: Go build using stacker cat > \"hello_stacker.go\" << EOF package main import \"fmt\" func main() { fmt.Println(\"Hello Stacker!\") } EOF cat > \"go_build.stacker.yaml\" << EOF go-build-hello-stacker: from: type: docker url: docker://zothub.io/c3/ubuntu/go-devel-amd64:1.19.2 import: - ./hello_stacker.go build_only: true run: | # Source Go toolchain env . /etc/profile # Setup Go ENV mkdir -p /go export GOPATH=/go mkdir -p /go/src cd /go/src # Copy source code to go path cp /stacker/hello_stacker.go . # Build code go build -o hello_stacker hello_stacker.go # Test code ./hello_stacker EOF stacker build -f go_build.stacker.yaml preparing image hello-go-stacker... using cached copy of /dev/shm/ravi/hello_stacker.go loading docker://zothub.io/c3/ubuntu/go-devel-amd64:1.19.2 Copying blob b900f44d647a skipped: already exists Copying config 3ece5b544e done Writing manifest to image destination Storing signatures cache miss because layer definition was changed + . /etc/profile + export 'HOME=/go' + export 'GOROOT=/opt/go' + export 'PATH=/opt/go/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin' + mkdir -p /tmp/go/cache + export 'GOCACHE=/tmp/go/cache' + mkdir -p /go + export 'GOPATH=/go' + mkdir -p /go/src + cd /go/src + cp /stacker/hello_stacker.go . + go build -o hello_stacker hello_stacker.go + ./hello_stacker Hello Stacker! The above script creates a go file called hello_stacker.go , then uses a go development container from zothub.io/c3/ubuntu/go-devel-amd:1.19.2 to build hello_stacker.go . Let's look at details of the stacker file sections used: Stacker file Keyword Description from specifies the base container to be used for this build import import file from host into the build container build_only mark this as a build container to avoid layer creation run build script to execute Note cp /stacker/hello_stacker.go . in the run script. Stacker bind mounts all the imported files under a special read-only directory /stacker . This directory can be used in the run script to access the host mounted files in the build script.","title":"Build Code"},{"location":"user_guide/build_code/#go-code-example","text":"As an example, let's build a simple go file using stacker: Go build using stacker cat > \"hello_stacker.go\" << EOF package main import \"fmt\" func main() { fmt.Println(\"Hello Stacker!\") } EOF cat > \"go_build.stacker.yaml\" << EOF go-build-hello-stacker: from: type: docker url: docker://zothub.io/c3/ubuntu/go-devel-amd64:1.19.2 import: - ./hello_stacker.go build_only: true run: | # Source Go toolchain env . /etc/profile # Setup Go ENV mkdir -p /go export GOPATH=/go mkdir -p /go/src cd /go/src # Copy source code to go path cp /stacker/hello_stacker.go . # Build code go build -o hello_stacker hello_stacker.go # Test code ./hello_stacker EOF stacker build -f go_build.stacker.yaml preparing image hello-go-stacker... using cached copy of /dev/shm/ravi/hello_stacker.go loading docker://zothub.io/c3/ubuntu/go-devel-amd64:1.19.2 Copying blob b900f44d647a skipped: already exists Copying config 3ece5b544e done Writing manifest to image destination Storing signatures cache miss because layer definition was changed + . /etc/profile + export 'HOME=/go' + export 'GOROOT=/opt/go' + export 'PATH=/opt/go/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin' + mkdir -p /tmp/go/cache + export 'GOCACHE=/tmp/go/cache' + mkdir -p /go + export 'GOPATH=/go' + mkdir -p /go/src + cd /go/src + cp /stacker/hello_stacker.go . + go build -o hello_stacker hello_stacker.go + ./hello_stacker Hello Stacker! The above script creates a go file called hello_stacker.go , then uses a go development container from zothub.io/c3/ubuntu/go-devel-amd:1.19.2 to build hello_stacker.go . Let's look at details of the stacker file sections used: Stacker file Keyword Description from specifies the base container to be used for this build import import file from host into the build container build_only mark this as a build container to avoid layer creation run build script to execute Note cp /stacker/hello_stacker.go . in the run script. Stacker bind mounts all the imported files under a special read-only directory /stacker . This directory can be used in the run script to access the host mounted files in the build script.","title":"Go Code Example"},{"location":"user_guide/build_container_image/","text":"Usually, developers use a two-stage build process to build a container image. In the first stage, make the binary for the container image, and in the second stage, build the runtime container image, including that binary. To accomplish this, stacker \"build only\" container builds the required binary and does not generate the corresponding OCI layer. Then copy this binary into the RFS of the runtime image such that the final container has only the required binary. Two-stage container image build cat > \"hello_stacker.go\" << EOF package main import \"fmt\" func main() { fmt.Println(\"Hello Stacker!\") } EOF cat > \"hello.stacker.yaml\" << EOF build-hello-stacker: from: type: docker url: docker://zothub.io/c3/ubuntu/go-devel-amd64:1.19.2 import: - ./hello_stacker.go build_only: true run: | # Source Go toolchain env . /etc/profile # Setup Go ENV mkdir -p /go export GOPATH=/go mkdir -p /go/src cd /go/src # Copy source code to go path cp /stacker/hello_stacker.go . # Build a static go binary go build -ldflags=\"-extldflags=-static\" -o hello_stacker.static hello_stacker.go cp hello_stacker.static / hello: from: type: docker url: docker://zothub.io/tools/busybox:stable import: - stacker://build-hello-stacker/hello_stacker.static run: | cp /stacker/hello_stacker.static /hello_stacker chmod +x /hello_stacker /hello_stacker # test EOF stacker build -f hello.stacker.yaml preparing image build-hello-stacker... copying /dev/shm/ravi/hello_stacker.go loading docker://zothub.io/c3/ubuntu/go-devel-amd64:1.19.2 Copying blob b900f44d647a done Copying config 3ece5b544e done Writing manifest to image destination Storing signatures + . /etc/profile + export 'HOME=/go' + export 'GOROOT=/opt/go' + export 'PATH=/opt/go/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin' + mkdir -p /tmp/go/cache + export 'GOCACHE=/tmp/go/cache' + mkdir -p /go + export 'GOPATH=/go' + mkdir -p /go/src + cd /go/src + cp /stacker/hello_stacker.go . + go build '-ldflags=-extldflags=-static' -o hello_stacker.static hello_stacker.go + cp hello_stacker.static / preparing image hello... loading docker://zothub.io/tools/busybox:stable Copying blob f5b7ce95afea done Copying config 74c82eccc6 done Writing manifest to image destination Storing signatures + cp /stacker/hello_stacker.static /hello_stacker + chmod +x /hello_stacker + /hello_stacker Hello Stacker! filesystem hello built successfully Info stacker://build-hello-stacker/hello_stacker.static import statement imports the specific binary file from the build-hello-stacker that is present in the build cache Lets verify that the hello layer has /hello_stacker file: stacker chroot stacker chroot -f hello.stacker.yaml hello This chroot is temporary, any changes will be destroyed when it exits. / # ls -al /hello_stacker -rwxrwxr-x 1 root root 1809694 Oct 26 01 :27 /hello_stacker / # exit","title":"Build Container Image"},{"location":"user_guide/build_environment/","text":"Stacker builds container images in a canonically defined environment, allowing stacker to guarantee repeatable builds by reproducing the same environment for all the builds for a given version of the stacker file. Runtime Environment \u00b6 Except for the term and proxy settings, none of the host environment variables leak into the stacker build environment. The run section of your build script can depend on these environment variables to perform the build. Let's examine the shell environment variables that stacker exposes to the build script in the run section of your stacker file: Stacker Build Environment cat > env_stacker.yaml << EOF env-stacker: from: type: docker url: docker://zothub.io/tools/busybox:stable run: | env build_only: true EOF stacker build -f env_stacker.yaml preparing image env-stacker... loading docker://zothub.io/tools/busybox:stable Copying blob f5b7ce95afea skipped: already exists Copying config 74c82eccc6 done Writing manifest to image destination Storing signatures cache miss because layer definition was changed + env HTTPS_PROXY = http://173.36.224.109:8080 no_proxy = localhost,127.0.0.1,localaddress,.localdomain.com,.cisco.com SHLVL = 1 NO_PROXY = localhost,127.0.0.1,localaddress,.localdomain.com,.cisco.com container = lxc https_proxy = http://173.36.224.109:8080 TERM = screen-256color PATH = /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin STACKER_LAYER_NAME = env-stacker PWD = / Note that only HTTPS_PROXY , https_proxy , NO_PROXY , no_proxy , and TERM are imported from the host, all other variables are standard shell variables. Root File System (RFS) \u00b6 Stacker creates a root file system defined by the layer in the from section and launches the build script in the run section using this file system. Stacker expects a \"sane\" file system in the base container so that it can execute sh to implement the run section. Let's examine the root file system that stacker exposes to the run script in the following example: Build RFS cat > rfs_stacker.yaml << EOF rfs-stacker: from: type: docker url: docker://zothub.io/tools/busybox:stable run: | ls -al / find /etc which cat build_only: true EOF stacker build -f rfs_stacker.yaml preparing image rfs-stacker... loading docker://zothub.io/tools/busybox:stable Copying blob f5b7ce95afea skipped: already exists Copying config 74c82eccc6 done Writing manifest to image destination Storing signatures + ls -al / total 0 drwxr-xr-x 1 root root 120 Oct 25 18 :30 . drwxr-xr-x 1 root root 120 Oct 25 18 :30 .. drwxr-xr-x 2 root root 8080 Oct 3 22 :04 bin drwxr-xr-x 4 root root 340 Oct 25 18 :30 dev drwxr-xr-x 1 root root 60 Oct 25 18 :30 etc drwxr-xr-x 2 nobody nobody 40 Oct 3 22 :04 home dr-xr-xr-x 2299 nobody nobody 0 Oct 25 18 :30 proc drwx------ 2 root root 40 Oct 3 22 :04 root drwxr-xr-x 2 root root 60 Oct 25 18 :30 stacker dr-xr-xr-x 13 nobody nobody 0 Sep 22 22 :12 sys drwxrwxrwt 2 root root 40 Oct 3 22 :04 tmp drwxr-xr-x 3 root root 60 Oct 3 22 :04 usr drwxr-xr-x 4 root root 80 Oct 3 22 :04 var + find /etc /etc /etc/shadow /etc/passwd /etc/network /etc/network/if-up.d /etc/network/if-pre-up.d /etc/network/if-post-down.d /etc/network/if-down.d /etc/localtime /etc/group /etc/resolv.conf + which cat /bin/cat The docker://zothub.io/tools/busybox:stable container defines the above file system, which has all the necessary utilities like /bin/cat and a basic system configuration required to operate most of the Linux utilities. Newtworking Setup \u00b6 Stacker builds the container images in the host network namespace. It bind mounts the host's /etc/resolv.conf into the build container's root file system to allow for correct DNS resolution as defined by the host. Finally, stacker re-exports the proxy settings to the environment to enable proxy-based access to any artifacts required to build the container image. Let's examine the networking setup that stacker exposes to the run script in the following example: Networking setup cat > network_stacker.yaml << EOF network-stacker: from: type: docker url: docker://zothub.io/tools/busybox:stable run: | echo \"HTTPS_PROXY=$HTTPS_PROXY\" cat /etc/resolv.conf ip addr build_only: true EOF stacker build -f network_stacker.yaml preparing image network-stacker... loading docker://zothub.io/tools/busybox:stable Copying blob f5b7ce95afea skipped: already exists Copying config 74c82eccc6 done Writing manifest to image destination Storing signatures + echo HTTPS_PROXY = http://173.36.224.109:8080 HTTPS_PROXY = http://173.36.224.109:8080 + cat /etc/resolv.conf # This is /run/systemd/resolve/stub-resolv.conf managed by man:systemd-resolved(8). # Do not edit. # # This file might be symlinked as /etc/resolv.conf. If you're looking at # /etc/resolv.conf and seeing this text, you have followed the symlink. # # This is a dynamic resolv.conf file for connecting local clients to the # internal DNS stub resolver of systemd-resolved. This file lists all # configured search domains. # # Run \"resolvectl status\" to see details about the uplink DNS servers # currently in use. # # Third party programs should typically not access this file directly, but only # through the symlink at /etc/resolv.conf. To manage man:resolv.conf(5) in a # different way, replace this symlink by a static file or a different symlink. # # See man:systemd-resolved.service(8) for details about the supported modes of # operation for /etc/resolv.conf. nameserver 127 .0.0.53 options edns0 trust-ad search cisco.com insieme.local + ip addr 1 : lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue qlen 1000 link/loopback 00 :00:00:00:00:00 brd 00 :00:00:00:00:00 inet 127 .0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2 : enp97s0f0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc mq qlen 1000 link/ether 3c:fd:fe:7f:27:a0 brd ff:ff:ff:ff:ff:ff 3 : enp97s0f1: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc mq qlen 1000 link/ether 3c:fd:fe:7f:27:a1 brd ff:ff:ff:ff:ff:ff 4 : enp97s0f2: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc mq qlen 1000 link/ether 3c:fd:fe:7f:27:a2 brd ff:ff:ff:ff:ff:ff 5 : enp97s0f3: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc mq qlen 1000 link/ether 3c:fd:fe:7f:27:a3 brd ff:ff:ff:ff:ff:ff 6 : enp1s0f0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq qlen 1000 link/ether b4:96:91:a4:44:d4 brd ff:ff:ff:ff:ff:ff inet 172 .20.61.165/24 brd 172 .20.61.255 scope global enp1s0f0 valid_lft forever preferred_lft forever inet6 fe80::b696:91ff:fea4:44d4/64 scope link valid_lft forever preferred_lft forever 7 : enp1s0f1: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc mq qlen 1000 link/ether b4:96:91:a4:44:d5 brd ff:ff:ff:ff:ff:ff 8 : lxcbr0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue qlen 1000 link/ether 00 :16:3e:00:00:00 brd ff:ff:ff:ff:ff:ff inet 10 .0.3.1/24 brd 10 .0.3.255 scope global lxcbr0 valid_lft forever preferred_lft forever 9 : docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue link/ether 02 :42:30:0d:77:ad brd ff:ff:ff:ff:ff:ff inet 172 .17.0.1/16 brd 172 .17.255.255 scope global docker0 valid_lft forever preferred_lft forever Since stacker is only used for building images, this is safe and intuitive for users on corporate networks with complicated proxy and other setups. However, it does mean that container packaging that expects to be able to modify things in /sys will fail since /sys is bind mounted from the host's /sys . sysfs cannot be mounted in a network namespace that a user doesn't own.","title":"Build Environment"},{"location":"user_guide/build_environment/#runtime-environment","text":"Except for the term and proxy settings, none of the host environment variables leak into the stacker build environment. The run section of your build script can depend on these environment variables to perform the build. Let's examine the shell environment variables that stacker exposes to the build script in the run section of your stacker file: Stacker Build Environment cat > env_stacker.yaml << EOF env-stacker: from: type: docker url: docker://zothub.io/tools/busybox:stable run: | env build_only: true EOF stacker build -f env_stacker.yaml preparing image env-stacker... loading docker://zothub.io/tools/busybox:stable Copying blob f5b7ce95afea skipped: already exists Copying config 74c82eccc6 done Writing manifest to image destination Storing signatures cache miss because layer definition was changed + env HTTPS_PROXY = http://173.36.224.109:8080 no_proxy = localhost,127.0.0.1,localaddress,.localdomain.com,.cisco.com SHLVL = 1 NO_PROXY = localhost,127.0.0.1,localaddress,.localdomain.com,.cisco.com container = lxc https_proxy = http://173.36.224.109:8080 TERM = screen-256color PATH = /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin STACKER_LAYER_NAME = env-stacker PWD = / Note that only HTTPS_PROXY , https_proxy , NO_PROXY , no_proxy , and TERM are imported from the host, all other variables are standard shell variables.","title":"Runtime Environment"},{"location":"user_guide/build_environment/#root-file-system-rfs","text":"Stacker creates a root file system defined by the layer in the from section and launches the build script in the run section using this file system. Stacker expects a \"sane\" file system in the base container so that it can execute sh to implement the run section. Let's examine the root file system that stacker exposes to the run script in the following example: Build RFS cat > rfs_stacker.yaml << EOF rfs-stacker: from: type: docker url: docker://zothub.io/tools/busybox:stable run: | ls -al / find /etc which cat build_only: true EOF stacker build -f rfs_stacker.yaml preparing image rfs-stacker... loading docker://zothub.io/tools/busybox:stable Copying blob f5b7ce95afea skipped: already exists Copying config 74c82eccc6 done Writing manifest to image destination Storing signatures + ls -al / total 0 drwxr-xr-x 1 root root 120 Oct 25 18 :30 . drwxr-xr-x 1 root root 120 Oct 25 18 :30 .. drwxr-xr-x 2 root root 8080 Oct 3 22 :04 bin drwxr-xr-x 4 root root 340 Oct 25 18 :30 dev drwxr-xr-x 1 root root 60 Oct 25 18 :30 etc drwxr-xr-x 2 nobody nobody 40 Oct 3 22 :04 home dr-xr-xr-x 2299 nobody nobody 0 Oct 25 18 :30 proc drwx------ 2 root root 40 Oct 3 22 :04 root drwxr-xr-x 2 root root 60 Oct 25 18 :30 stacker dr-xr-xr-x 13 nobody nobody 0 Sep 22 22 :12 sys drwxrwxrwt 2 root root 40 Oct 3 22 :04 tmp drwxr-xr-x 3 root root 60 Oct 3 22 :04 usr drwxr-xr-x 4 root root 80 Oct 3 22 :04 var + find /etc /etc /etc/shadow /etc/passwd /etc/network /etc/network/if-up.d /etc/network/if-pre-up.d /etc/network/if-post-down.d /etc/network/if-down.d /etc/localtime /etc/group /etc/resolv.conf + which cat /bin/cat The docker://zothub.io/tools/busybox:stable container defines the above file system, which has all the necessary utilities like /bin/cat and a basic system configuration required to operate most of the Linux utilities.","title":"Root File System (RFS)"},{"location":"user_guide/build_environment/#newtworking-setup","text":"Stacker builds the container images in the host network namespace. It bind mounts the host's /etc/resolv.conf into the build container's root file system to allow for correct DNS resolution as defined by the host. Finally, stacker re-exports the proxy settings to the environment to enable proxy-based access to any artifacts required to build the container image. Let's examine the networking setup that stacker exposes to the run script in the following example: Networking setup cat > network_stacker.yaml << EOF network-stacker: from: type: docker url: docker://zothub.io/tools/busybox:stable run: | echo \"HTTPS_PROXY=$HTTPS_PROXY\" cat /etc/resolv.conf ip addr build_only: true EOF stacker build -f network_stacker.yaml preparing image network-stacker... loading docker://zothub.io/tools/busybox:stable Copying blob f5b7ce95afea skipped: already exists Copying config 74c82eccc6 done Writing manifest to image destination Storing signatures + echo HTTPS_PROXY = http://173.36.224.109:8080 HTTPS_PROXY = http://173.36.224.109:8080 + cat /etc/resolv.conf # This is /run/systemd/resolve/stub-resolv.conf managed by man:systemd-resolved(8). # Do not edit. # # This file might be symlinked as /etc/resolv.conf. If you're looking at # /etc/resolv.conf and seeing this text, you have followed the symlink. # # This is a dynamic resolv.conf file for connecting local clients to the # internal DNS stub resolver of systemd-resolved. This file lists all # configured search domains. # # Run \"resolvectl status\" to see details about the uplink DNS servers # currently in use. # # Third party programs should typically not access this file directly, but only # through the symlink at /etc/resolv.conf. To manage man:resolv.conf(5) in a # different way, replace this symlink by a static file or a different symlink. # # See man:systemd-resolved.service(8) for details about the supported modes of # operation for /etc/resolv.conf. nameserver 127 .0.0.53 options edns0 trust-ad search cisco.com insieme.local + ip addr 1 : lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue qlen 1000 link/loopback 00 :00:00:00:00:00 brd 00 :00:00:00:00:00 inet 127 .0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2 : enp97s0f0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc mq qlen 1000 link/ether 3c:fd:fe:7f:27:a0 brd ff:ff:ff:ff:ff:ff 3 : enp97s0f1: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc mq qlen 1000 link/ether 3c:fd:fe:7f:27:a1 brd ff:ff:ff:ff:ff:ff 4 : enp97s0f2: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc mq qlen 1000 link/ether 3c:fd:fe:7f:27:a2 brd ff:ff:ff:ff:ff:ff 5 : enp97s0f3: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc mq qlen 1000 link/ether 3c:fd:fe:7f:27:a3 brd ff:ff:ff:ff:ff:ff 6 : enp1s0f0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq qlen 1000 link/ether b4:96:91:a4:44:d4 brd ff:ff:ff:ff:ff:ff inet 172 .20.61.165/24 brd 172 .20.61.255 scope global enp1s0f0 valid_lft forever preferred_lft forever inet6 fe80::b696:91ff:fea4:44d4/64 scope link valid_lft forever preferred_lft forever 7 : enp1s0f1: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc mq qlen 1000 link/ether b4:96:91:a4:44:d5 brd ff:ff:ff:ff:ff:ff 8 : lxcbr0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue qlen 1000 link/ether 00 :16:3e:00:00:00 brd ff:ff:ff:ff:ff:ff inet 10 .0.3.1/24 brd 10 .0.3.255 scope global lxcbr0 valid_lft forever preferred_lft forever 9 : docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue link/ether 02 :42:30:0d:77:ad brd ff:ff:ff:ff:ff:ff inet 172 .17.0.1/16 brd 172 .17.255.255 scope global docker0 valid_lft forever preferred_lft forever Since stacker is only used for building images, this is safe and intuitive for users on corporate networks with complicated proxy and other setups. However, it does mean that container packaging that expects to be able to modify things in /sys will fail since /sys is bind mounted from the host's /sys . sysfs cannot be mounted in a network namespace that a user doesn't own.","title":"Newtworking Setup"},{"location":"user_guide/debugging/","text":"The first step to trying to find a bug in stacker is to run it with --debug. This will give you a stack trace from where (at least in stacker's code) the error originated via github.com/pkg/errors . Sometimes it is useful to write a small reproducer in test/ , and run it with: make check TEST = myreproducer.bats Overlayfs / layer issues \u00b6 Another thing --debug will show you is what overlay arguments it is sending to LXC. Note that the build overlay filesystem never exists in the host mount namespace, but is created by liblxc in the child namespace. Sometimes it can be useful to take these overlay args and split up the lowerdirs: ./stacker/stacker_layers/.roots/sha256_f8e46c301da6347e78057d8fe48a6bbd8fc0cab213d47825f5c0c0646f542b6b/overlay ./stacker/stacker_layers/.roots/sha256_7eb8e296d351fe6d0c87fea979b305e2b1f19548d99f9aee4b8030b596f02efd/overlay ./stacker/stacker_layers/.roots/sha256_ca379e914166030218007477a7b9cfd0ca3dd554c58e2401c58c634fac9182f8/overlay and look through each one (top to bottom, as the overlay stack would present) in order to see what's going on. Debugging LXC \u00b6 If things are really bad, you may end up wading through liblxc. With --debug , stacker will also try and render any liblxc ERRORs to stdout, but sometimes it can be useful to see a full liblxc trace log. This is available in $(--stacker-dir)/lxc.log for the last run. If you get even more in the weeds, you may need to build your own liblxc with debug statements. Thankfully, everything is statically linked so this is fairly easy to test locally, as long as your host liblxc can build stacker: make LXC_CLONE_URL = https://github.com/tych0/lxc LXC_BRANCH = my-debug-branch Stacker links against this through a convoluted mechanism: it builds a static C program in /cmd/lxc-wrapper/ that takes a few relevant arguments about what mode to drive liblxc in. Stacker uses the go-embed mechanism to embed the resulting statically linked binary, and then resolves and execs it at runtime via the code in /embed-exec . The reason for all this indirection vs. linking against something directly is that the kernel does not allow multithreaded programs to unshare user namespaces. Since the go runtime spawns many threads for GC and various other tasks, go code cannot directly unshare a user namespace (one wonders, then, why this was the language chosen for runc, lxd, etc...). A previous implementation (the one in lxd) was to use some __attribute__((constructor)) nonsense and hope for the best, but it doesn't work in all cases, and go-embed allows for librar-ization of stacker code if someone else wants to use it eventually. See 8fa336834f31 (\"container: move to go-embed for re-exec of C code\") for details on that approach. Overlay storage layout \u00b6 The storage parent directory is whatever is specified to stacker via --roots-dir . Each layer is extracted into a sha256_$hash/overlay directory, which is then sewn together via overlayfs. At the top level, for a layer called foo , there are two directories: foo/rootfs , and foo/overlay . During the build, foo 's rootfs is mounted inside the container as foo/rootfs , with the overlay upperdir=foo/overlay . This way, whatever filesystem mutations the foo layer's run: section performs end up in foo/overlay . After the run: section, stacker generates whatever layers the user requested from this, creates sha256_$hash/overlay dirs with the contents (if two layer types were converted, then the hash of the squashfs output will just be a symlink to the tar layer's directory to save space), and foo/overlay_metadata.json will be updated to reflect these new outputs, for use when e.g. foo is a dependency of some other layer bar . Note that there is currently one wart. In a stacker file like: foo : from : type : docker url : docker://ubuntu:latest build_only : true run : | dd if=/dev/random of=/bigfile bs=1M count=1000 bar : from : type : built tag : foo run : | rm /bigfile The final image for bar will actually contain a layer with /bigfile in it, because the foo layer's mutations are generated independently of bar 's. Some clever userspace overlay collapsing could be done here to remove this wart, though.","title":"Debugging"},{"location":"user_guide/debugging/#overlayfs-layer-issues","text":"Another thing --debug will show you is what overlay arguments it is sending to LXC. Note that the build overlay filesystem never exists in the host mount namespace, but is created by liblxc in the child namespace. Sometimes it can be useful to take these overlay args and split up the lowerdirs: ./stacker/stacker_layers/.roots/sha256_f8e46c301da6347e78057d8fe48a6bbd8fc0cab213d47825f5c0c0646f542b6b/overlay ./stacker/stacker_layers/.roots/sha256_7eb8e296d351fe6d0c87fea979b305e2b1f19548d99f9aee4b8030b596f02efd/overlay ./stacker/stacker_layers/.roots/sha256_ca379e914166030218007477a7b9cfd0ca3dd554c58e2401c58c634fac9182f8/overlay and look through each one (top to bottom, as the overlay stack would present) in order to see what's going on.","title":"Overlayfs / layer issues"},{"location":"user_guide/debugging/#debugging-lxc","text":"If things are really bad, you may end up wading through liblxc. With --debug , stacker will also try and render any liblxc ERRORs to stdout, but sometimes it can be useful to see a full liblxc trace log. This is available in $(--stacker-dir)/lxc.log for the last run. If you get even more in the weeds, you may need to build your own liblxc with debug statements. Thankfully, everything is statically linked so this is fairly easy to test locally, as long as your host liblxc can build stacker: make LXC_CLONE_URL = https://github.com/tych0/lxc LXC_BRANCH = my-debug-branch Stacker links against this through a convoluted mechanism: it builds a static C program in /cmd/lxc-wrapper/ that takes a few relevant arguments about what mode to drive liblxc in. Stacker uses the go-embed mechanism to embed the resulting statically linked binary, and then resolves and execs it at runtime via the code in /embed-exec . The reason for all this indirection vs. linking against something directly is that the kernel does not allow multithreaded programs to unshare user namespaces. Since the go runtime spawns many threads for GC and various other tasks, go code cannot directly unshare a user namespace (one wonders, then, why this was the language chosen for runc, lxd, etc...). A previous implementation (the one in lxd) was to use some __attribute__((constructor)) nonsense and hope for the best, but it doesn't work in all cases, and go-embed allows for librar-ization of stacker code if someone else wants to use it eventually. See 8fa336834f31 (\"container: move to go-embed for re-exec of C code\") for details on that approach.","title":"Debugging LXC"},{"location":"user_guide/debugging/#overlay-storage-layout","text":"The storage parent directory is whatever is specified to stacker via --roots-dir . Each layer is extracted into a sha256_$hash/overlay directory, which is then sewn together via overlayfs. At the top level, for a layer called foo , there are two directories: foo/rootfs , and foo/overlay . During the build, foo 's rootfs is mounted inside the container as foo/rootfs , with the overlay upperdir=foo/overlay . This way, whatever filesystem mutations the foo layer's run: section performs end up in foo/overlay . After the run: section, stacker generates whatever layers the user requested from this, creates sha256_$hash/overlay dirs with the contents (if two layer types were converted, then the hash of the squashfs output will just be a symlink to the tar layer's directory to save space), and foo/overlay_metadata.json will be updated to reflect these new outputs, for use when e.g. foo is a dependency of some other layer bar . Note that there is currently one wart. In a stacker file like: foo : from : type : docker url : docker://ubuntu:latest build_only : true run : | dd if=/dev/random of=/bigfile bs=1M count=1000 bar : from : type : built tag : foo run : | rm /bigfile The final image for bar will actually contain a layer with /bigfile in it, because the foo layer's mutations are generated independently of bar 's. Some clever userspace overlay collapsing could be done here to remove this wart, though.","title":"Overlay storage layout"},{"location":"user_guide/dependency_builds/","text":"","title":"Dependency Builds"},{"location":"user_guide/grab_image_content/","text":"","title":"Grab Image Content"},{"location":"user_guide/image_chroot/","text":"","title":"Image Chroot"},{"location":"user_guide/inspect_images/","text":"","title":"Inspect Images"},{"location":"user_guide/publish_images/","text":"","title":"Publish Images"},{"location":"user_guide/scratch_image/","text":"Building container image from scratch \u00b6 There are a couple of cases where it may be useful to build a layer from scratch. For example to derive a new base install of an OS or to build a \"tarball\" type image which just carries data and will not actually be run by a container runtime. The way to accomplish this in stacker is to use a build only layer (i.e. a layer that does not get emitted into the final OCI image, perhaps containing assets or something that will be used by the final container). The best way to accomplish this is as follows: build: from: type: docker url: docker://ubuntu:latest run: | touch /tmp/first touch /tmp/second tar -C /tmp -cv -f /contents.tar first second build_only: true contents: from: type: tar url: stacker://build/contents.tar Or e.g. to bootstrap a base layer for CentoOS 7: build: from: type: docker url: docker://ubuntu:latest run: | yum -y --installroot=/rootfs --nogpgcheck install tar -C rootfs -zcf /rootfs.tar . build_only: true contents: from: type: tar url: stacker://build/rootfs.tar These work by creating the base for the system in a build container with all the utilities available needed to manipulate that base, and then asking stacker to create a layer based on this tarball, without actually running anything inside of the layer (which means e.g. absence of a shell or libc or whatever is fine). Another way to accomplish something similar is to use a distroless layer: build: from: type: docker url: docker://ubuntu:latest binds: - /tmp/dir_to_overlay -> /dir_to_overlay run: | touch /dir_to_overlay/binaryfile build_only: true contents: from: type: docker url: docker://zothub.io/project-stacker/c3/base overlay_dirs: - source: /tmp/dir_to_overlay dest: /dir_to_overlay You can use the first layer as a build env, and copy your binary to a bind-mounted folder. Use overlay_dirs with that same folder to have the binary in the distroless layer.","title":"Scratch Image"},{"location":"user_guide/scratch_image/#building-container-image-from-scratch","text":"There are a couple of cases where it may be useful to build a layer from scratch. For example to derive a new base install of an OS or to build a \"tarball\" type image which just carries data and will not actually be run by a container runtime. The way to accomplish this in stacker is to use a build only layer (i.e. a layer that does not get emitted into the final OCI image, perhaps containing assets or something that will be used by the final container). The best way to accomplish this is as follows: build: from: type: docker url: docker://ubuntu:latest run: | touch /tmp/first touch /tmp/second tar -C /tmp -cv -f /contents.tar first second build_only: true contents: from: type: tar url: stacker://build/contents.tar Or e.g. to bootstrap a base layer for CentoOS 7: build: from: type: docker url: docker://ubuntu:latest run: | yum -y --installroot=/rootfs --nogpgcheck install tar -C rootfs -zcf /rootfs.tar . build_only: true contents: from: type: tar url: stacker://build/rootfs.tar These work by creating the base for the system in a build container with all the utilities available needed to manipulate that base, and then asking stacker to create a layer based on this tarball, without actually running anything inside of the layer (which means e.g. absence of a shell or libc or whatever is fine). Another way to accomplish something similar is to use a distroless layer: build: from: type: docker url: docker://ubuntu:latest binds: - /tmp/dir_to_overlay -> /dir_to_overlay run: | touch /dir_to_overlay/binaryfile build_only: true contents: from: type: docker url: docker://zothub.io/project-stacker/c3/base overlay_dirs: - source: /tmp/dir_to_overlay dest: /dir_to_overlay You can use the first layer as a build env, and copy your binary to a bind-mounted folder. Use overlay_dirs with that same folder to have the binary in the distroless layer.","title":"Building container image from scratch"},{"location":"user_guide/template_substitution/","text":"","title":"Template Substitution"}]}